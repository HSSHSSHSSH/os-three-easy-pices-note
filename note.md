## 在 windows 上使用 wsl 运行 linux 程序
- 安装 wsl

  ```shell
  wsl --install -d Ubuntu
  ```

  进入 wsl 

  ``` shell
  wsl -d Ubuntu
  ```

- 安装 gcc 与 build-essential

  ```shell
  sudo apt-get install gcc
  sudo apt-get install build-essential
  ```

之后就可以在 wsl 中使用 gcc 编译 linux c 程序了。

## Unix/Linux进程与文件描述符学习笔记

### 1. 文件描述符基础
- **定义**：文件描述符是一个非负整数，用于标识进程打开的文件或I/O资源
- **标准文件描述符**：
  - 0 (STDIN_FILENO)：标准输入，默认连接到键盘
  - 1 (STDOUT_FILENO)：标准输出，默认连接到终端屏幕
  - 2 (STDERR_FILENO)：标准错误，默认连接到终端屏幕
- **特点**：
  - 每个进程都有独立的文件描述符表
  - 文件描述符只是索引值，本身没有特殊功能
  - 新打开的文件会获得当前可用的最小描述符号

### 2. 进程创建与文件描述符继承
- **fork()函数**：
  - 创建当前进程的副本(子进程)
  - 子进程继承父进程的整个文件描述符表
  - 子进程之后对描述符的修改不影响父进程
  - 返回值：父进程中返回子进程PID，子进程中返回0

- **exec()函数族**：
  - 用新程序替换当前进程的内容
  - 保留文件描述符表(除非设置了FD_CLOEXEC标志)
  - 替换后，原进程的代码不再执行

### 3. I/O重定向实现
- **关闭和打开描述符**：
  ```c
  close(STDOUT_FILENO);  // 关闭描述符1
  open("output.txt", O_WRONLY|O_CREAT, 0644);  // 获取描述符1
  ```
  
- **open()函数参数**：
  - 第一个参数：文件路径
  - 第二个参数：打开标志(O_RDONLY, O_WRONLY, O_CREAT等)
  - 第三个参数：权限模式(仅当创建文件时使用)

- **重定向的工作原理**：
  - close()释放特定的描述符号
  - open()会使用最小可用的描述符号
  - 结合使用实现了文件描述符的"重用"

- **dup/dup2函数**：
  - `dup(fd)`：复制描述符，返回新描述符
  - `dup2(oldfd, newfd)`：将newfd指向与oldfd相同的文件

### 4. 缓冲区机制
- **stdio库的缓冲模式**：
  - **行缓冲**：终端设备的默认模式，遇到换行符刷新
  - **完全缓冲**：普通文件的默认模式，缓冲区满或显式刷新才写入
  - **无缓冲**：数据立即写入，不经过缓冲区(如stderr通常是无缓冲的)

- **缓冲区刷新时机**：
  - 缓冲区满时
  - 遇到换行符(仅限行缓冲模式)
  - 程序正常结束
  - 显式调用fflush()

- **exec()前的缓冲区管理**：
  - exec()会替换进程，包括未刷新的缓冲区
  - 必须在exec()前调用fflush()确保数据写入
  - 或使用无缓冲的写入函数，如write()

- **C标准库中的缓冲函数**：
  - 几乎所有stdio的I/O函数都使用缓冲：
    - 输出：printf(), fprintf(), fputs(), fwrite(), putc()/fputc(), puts()
    - 输入：scanf(), fscanf(), fgets(), fread(), getc()/fgetc()
  - 系统调用级函数不使用stdio缓冲：
    - write(), read() 等直接系统调用不经过stdio缓冲机制

- **控制缓冲区行为**：
  - `setvbuf(FILE *stream, char *buf, int mode, size_t size)` - 设置流的缓冲模式
    - 模式参数：_IONBF(无缓冲)、_IOLBF(行缓冲)、_IOFBF(完全缓冲)
  - `setbuf(FILE *stream, char *buf)` - 简化版的setvbuf
  - `fflush(FILE *stream)` - 强制刷新指定流的缓冲区

- **其他编程语言中的缓冲机制**：
  - **Python**：
    - print()函数默认使用缓冲的stdout
    - 可以通过print(..., flush=True)强制刷新
    - 文件操作可以指定缓冲模式：open(file, buffering=0/1/-1)
    - sys.stdout.flush()方法显式刷新缓冲区
  
  - **JavaScript (Node.js)**：
    - process.stdout有缓冲机制
    - console.log()使用这些缓冲流
    - Node.js的流(Streams)API有内置缓冲控制
    - 可通过stream.cork()和stream.uncork()管理缓冲行为

- **缓冲区的性能影响**：
  - 缓冲区增大I/O操作效率，减少系统调用次数
  - 缓冲可能导致数据不是实时可见
  - 关键应用场景(如日志)需要权衡缓冲效率和实时性
  - 进程意外终止可能导致缓冲数据丢失


### 5. 实际应用示例
- **简单重定向**：
  ```c
  close(STDOUT_FILENO);
  open("output.txt", O_WRONLY|O_CREAT, 0644);
  printf("输出到文件\n");
  fflush(stdout);  // 确保数据写入文件
  ```

- **命令执行与重定向**：
  ```c
  if (fork() == 0) {  // 子进程
      close(STDOUT_FILENO);
      open("output.txt", O_WRONLY|O_CREAT, 0644);
      execlp("ls", "ls", "-l", NULL);  // ls的输出会写入文件
  }
  ```

- **等效的Shell命令**：
  ```bash
  ls -l > output.txt
  ```

### 6. 核心概念总结
- Unix/Linux的"一切皆文件"哲学使I/O操作统一
- 标准文件描述符是约定，而非硬性规定
- 文件描述符表是进程的属性，子进程继承，exec后保留
- 重定向的本质是改变文件描述符的指向
- 缓冲区行为取决于输出目标类型

## 操作系统CPU虚拟化机制学习笔记

### 1. 有限直接执行(Limited Direct Execution)基础
- **定义**：操作系统用于CPU虚拟化的基本机制，用于解决如何让程序高效运行，同时保持操作系统对系统的控制
- **面临的核心问题**：
  - 效率问题：如何在虚拟化CPU的同时不引入过多性能开销
  - 控制问题：如何确保操作系统能够保持对计算机的控制

### 2. 直接执行及其局限性
- **直接执行的基本流程**：
  - 创建进程的地址空间
  - 加载程序代码到内存
  - 设置栈指针到栈顶
  - 跳转到程序入口点(main函数)
  - 程序开始执行
  - 程序结束，通过系统调用退出

- **直接执行的问题**：
  - 特权操作：用户程序可能执行任何指令，包括特权指令，威胁系统安全
  - 资源控制：无法限制程序对CPU和内存等资源的使用
  - 进程切换：操作系统无法从运行中的程序夺回控制权
  - 系统调用：程序无法安全地请求操作系统服务

### 3. "有限"直接执行的解决方案

#### 3.1 处理器模式(Processor Modes)
- **内核模式(Kernel Mode)**：
  - 也称为特权模式，可以执行任何指令
  - 可以访问任何内存
  - 可以控制所有硬件设备

- **用户模式(User Mode)**：
  - 受限模式，某些指令被禁止
  - 某些内存区域无法访问
  - 需要通过系统调用请求特权操作

- **处理器模式的切换**：
  - 系统启动时，CPU处于内核模式
  - 创建进程并准备运行用户程序时，操作系统切换到用户模式
  - 当发生系统调用、中断或异常时，CPU切换回内核模式
  - 操作系统完成任务后，切换回用户模式继续运行程序

#### 3.2 系统调用机制(System Calls)
- **作用**：
  - 允许用户程序请求操作系统服务
  - 保护系统安全
  - 提供标准化的API

- **实现原理**：
  - 用户程序通过特殊指令触发从用户模式到内核模式的切换
  - 操作系统有一个系统调用表，将系统调用号映射到相应的内核函数
  - 用户程序无法直接调用内核函数，必须通过系统调用接口

- **系统调用的典型流程**：
  1. 用户程序设置系统调用参数(通常在寄存器中)
  2. 执行特殊的陷入(trap)指令
  3. 硬件将控制权转交给操作系统，同时切换到内核模式
  4. 操作系统执行系统调用处理程序
  5. 操作系统根据系统调用号执行相应函数
  6. 操作系统返回结果，切换回用户模式
  7. 用户程序继续执行

#### 3.3 中断机制(Interrupts)
- **概念**：
  - 中断允许操作系统在外部事件发生时重新获得控制权
  - 提供了一种异步响应机制
  
- **工作过程**：
  - 硬件设备(如定时器、键盘、网卡)可以触发中断
  - 中断触发时，CPU暂停当前程序执行，切换到内核模式
  - 操作系统执行中断处理程序，处理相应事件
  - 处理完毕后，操作系统可以选择返回原程序或切换到另一个程序

#### 3.4 定时器中断与上下文切换
- **定时器中断的作用**：
  - 操作系统初始化时设置定时器，定期产生中断
  - 当定时器中断触发时，操作系统获得控制权
  - 实现操作系统的抢占式调度

- **上下文切换过程**：
  1. 保存当前运行进程的状态(寄存器、栈指针等)
  2. 选择下一个要运行的进程
  3. 恢复被选中进程的状态
  4. 切换到用户模式，恢复被选中进程的执行

### 4. 有限直接执行的实现细节

#### 4.1 上下文切换的具体步骤
- **硬件层面**：
  - 定时器中断触发，硬件自动保存部分CPU状态
  - CPU模式从用户模式切换到内核模式
  - CPU跳转到预定义的中断处理程序位置

- **软件层面(内核执行)**：
  - 保存剩余的寄存器状态到内核栈
  - 保存用户栈指针
  - 执行调度算法，选择下一个要运行的进程
  - 恢复新进程的寄存器状态
  - 恢复新进程的栈指针
  - 执行返回指令，切换回用户模式

#### 4.2 陷入与返回指令
- **陷入指令(trap)**：
  - 允许用户程序安全地进入内核(如系统调用)
  - 示例：x86上的`int`指令或更现代的`syscall`/`sysenter`

- **返回指令(return-from-trap)**：
  - 允许内核安全地返回用户程序
  - 特权指令，只能在内核模式执行

- **这些指令的保证**：
  - 正确保存并恢复程序状态
  - 安全地切换处理器模式
  - 跳转到正确的内核或用户代码位置

#### 4.3 陷阱表(Trap Table)
- **定义**：
  - 一个包含各种异常(系统调用、中断、错误)处理程序地址的表格
  - 也称为中断向量表或异常向量表

- **工作机制**：
  - 系统启动时，操作系统在特定内存位置设置陷阱表
  - 操作系统使用特权指令告诉硬件陷阱表的位置
  - 当异常发生时，硬件查询陷阱表，跳转到相应处理程序

### 5. 有限直接执行的优势与挑战
- **优势**：
  - 高性能：大多数时间用户程序直接在CPU上运行，无额外开销
  - 安全性：通过处理器模式和系统调用机制保护系统
  - 资源控制：操作系统可以定期重获控制权，实现资源管理
  - 多任务支持：通过定时器中断和上下文切换实现时间共享

- **挑战**：
  - 上下文切换开销：保存和恢复状态需要时间，频繁切换会影响性能
  - 缓存和TLB失效：进程切换可能导致缓存和TLB内容失效，影响性能
  - 系统调用开销：系统调用涉及模式切换，比普通函数调用开销大
  - 中断延迟：从中断触发到处理有一定延迟，影响实时性要求